


#include "lcd1602.h"
#include "utilities.h"

#if LCD_I2C==1
#include "mcp23008.h"
#define MCP23008_I2C_BUS            I2C2
#endif

#if LCD_PMP==1
#include <plib.h>
#include <define_pins.h>

// Pre-defined bit masks are located in the PIC32MX PMP peripheral library header file
// pmp.h
#define CONTROL     ( 1<<_PMCON_ON_POSITION | 0<<_PMCON_SIDL_POSITION | 0<<_PMCON_ADRMUX_POSITION  | 1<<_PMCON_PTWREN_POSITION|\
                     1<<_PMCON_CSF_POSITION | 0<<_PMCON_ALP_POSITION  | 0<<_PMCON_CS2P_POSITION    |\
                     0<<_PMCON_WRSP_POSITION  )

#define MODE        ( 1<<_PMMODE_MODE16_POSITION | 3<<_PMMODE_MODE_POSITION |\
                     2<<_PMMODE_WAITB0_POSITION  | 7<<_PMMODE_WAITM_POSITION| 3<<_PMMODE_WAITE_POSITION  )



DEFINE_PIN(LCD_DATA_CMD, G, 14)      // From PAD00
DEFINE_PIN(LCD_ENABLE, D, 12)        // From PAD15 or CS2
DEFINE_PIN(LCD_RW, D, 10)            // From 
DEFINE_PIN(LCD_LED,G,13)             // 

#endif


//Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
//MikroeElektronika 2011
//http://www.mikroe.com

//HD44780 Alpha Numeric Character Set - FontName : RTC5x8
//HD44780 Alpha Numeric Character Set - FontSize : 5 x 8

const uint8_t SPECCHAR5x8[] = {
    0x08, 0x14, 0x08, 0x03, 0x04, 0x07, 0x04, 0x04, // Code for char num #0 Faranheit
    0x08, 0x14, 0x08, 0x03, 0x04, 0x04, 0x03, 0x00, // Code for char num #1 Celcius
    0x04, 0x0A, 0x0E, 0x0A, 0x00, 0x1A, 0x15, 0x15, // Code for char num #2 AM
    0x04, 0x0A, 0x0C, 0x08, 0x00, 0x1A, 0x15, 0x15, // Code for char num #3 PM
    0x0C, 0x12, 0x12, 0x0C, 0x00, 0x00, 0x00, 0x00, // Code for char num #4 Degrees
    0x00, 0x01, 0x01, 0x05, 0x05, 0x15, 0x15, 0x00, // Code for char num #5 Bar
    0x00, 0x15, 0x0E, 0x04, 0x04, 0x04, 0x04, 0x00, // Code for char num #6 Antenna
    0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x00 // Code for char num #7 Battery Full
};

const uint8_t SPECCHAR5x8_1[] = {
    0x02, 0x05, 0x01, 0x12, 0x07, 0x13, 0x14, 0x13, // Code for char num #0 - i2c
    0x04, 0x0E, 0x0E, 0x0E, 0x0E, 0x1F, 0x00, 0x04, // Code for char num #1 - Bell
    0x1C, 0x14, 0x1C, 0x0E, 0x0B, 0x0E, 0x03, 0x02, // Code for char num #2 - Off
    0x1C, 0x14, 0x1C, 0x00, 0x12, 0x1A, 0x16, 0x00, // Code for char num #3 - On
    0x01, 0x03, 0x05, 0x09, 0x09, 0x0B, 0x1B, 0x18, // Code for char num #4 - Music
    0x00, 0x0A, 0x1F, 0x1F, 0x1F, 0x0E, 0x04, 0x00, // Code for char num #5 - Heart
    0x04, 0x0E, 0x1F, 0x04, 0x04, 0x04, 0x04, 0x00, // Code for char num #6 - Up
    0x04, 0x04, 0x04, 0x04, 0x1F, 0x0E, 0x04, 0x00 // Code for char num #7 - Down
};


UINT8 buff[128];
UINT8 lcdbuffer; // Buffer to hold data to tranfer to LCD
UINT32 actualClock;
UINT8 lcd2004_line;

PRIVATE UCHAR8 txbuff[12];
PRIVATE uint8_t status;
void LCD1602_InitHD44780CustomChars(void);

void LCD1602_Init(void)
{
#if LCD_I2C==1
    mcp23008_init();
    MCP23008_IOCON_REG_sType iocon;
    iocon.DISSLW = 0;
    iocon.HAEN = 1;
    iocon.INTPOL = 1;
    iocon.ODR = 1;
    iocon.SEQOP = 1;
    mcp23008_ConfigIOCON(&iocon, MCP23008_LCD_ADDR);

    mcp23008_SetGPIODir(0, MCP23008_LCD_ADDR);
    mcp23008_SetIPOL(0, MCP23008_LCD_ADDR);

    //first init string
    mcp23008_WriteGPIO(0x93, MCP23008_LCD_ADDR);
    ShortDelay(delay_5ms);
    mcp23008_WriteGPIO(0x83, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);

    //second init string
    mcp23008_WriteGPIO(0x93, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
    mcp23008_WriteGPIO(0x83, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);

    //third init string
    mcp23008_WriteGPIO(0x93, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
    mcp23008_WriteGPIO(0x83, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);

    //fourth init string
    // 4 bits mode, only per indications of initializaton
    mcp23008_WriteGPIO(0x92, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
    mcp23008_WriteGPIO(0x82, MCP23008_LCD_ADDR);    
    ShortDelay(delay_1ms);

    // 4 bits mode, only per indications of initializaton
    LCD1602_Write(LCD_FUNCTIONSET | LCD_5x8DOTS | LCD_4BITMODE | LCD_2LINE, RS_CMD);
    
    // Display ON
    LCD1602_Write(LCD_DISPLAYCONTROL | LCD_DISPLAYON, RS_CMD);

    // Clear Display,
    LCD1602_Write(LCD_CLEARDISPLAY, RS_CMD);

    // Entry Mode Set
    LCD1602_Write(LCD_ENTRYMODESET | LCD_ENTRYLEFT, RS_CMD);

#endif

#if LCD_PMP==1
    PMCON = CONTROL;
    PMMODE = MODE;
    mPMPEnable();
    LCD_RW_OUTPUT();
    LCD_DATA_CMD_OUTPUT();
    LCD_LED_OUTPUT();
    LCD_ENABLE_OUTPUT();
    LCD_LED_HIGH();
    
//    LCD_RW_LOW();
//    LCD_DATA_CMD_LOW();
//    
//    while (mIsPMPBusy());
//    PMDIN = 0x30;
//    LCD_ENABLE_LOW();
//    ShortDelay(delay_1ms);
//    LCD_ENABLE_HIGH();
    
    LCD1602_Write(0x30,0);
    ShortDelay(delay_5ms);
    LCD1602_Write(0x30,0);
    ShortDelay(delay_5ms);
    LCD1602_Write(0x30,0);
    
    // 8 bits mode, only per indications of initialization
    LCD1602_Write(LCD_FUNCTIONSET | LCD_5x8DOTS | LCD_8BITMODE | LCD_2LINE, 0);
    
    // Display ON
    LCD1602_Write(LCD_DISPLAYCONTROL | LCD_DISPLAYON, 0);

    // Clear Display,
    LCD1602_Write(LCD_CLEARDISPLAY, 0);

    // Entry Mode Set
    LCD1602_Write(LCD_ENTRYMODESET | LCD_ENTRYLEFT, 0);
#endif

    LCD1602_InitHD44780CustomChars();
}

void LCD1602_SetDisplayOnOff(BOOL status)
{
    if (status)
    {
        LCD1602_Write(LCD_DISPLAYCONTROL | LCD_DISPLAYON, 0);
    }
    else
    {
        LCD1602_Write(LCD_DISPLAYCONTROL | LCD_DISPLAYOFF, 0);
    }
}

void LCD1602_SetCursorOnOff(BOOL status)
{
    if (status)
    {
        LCD1602_Write(LCD_DISPLAYCONTROL | LCD_CURSORON, 0);
    }
    else
    {
        LCD1602_Write(LCD_DISPLAYCONTROL | LCD_CURSOROFF, 0);
    }
}

void LCD1602_Write(UCHAR8 data, UCHAR8 RegSel)
{
#if LCD_I2C==1
    //printf("Data is: %x Register Select is: %x\n",data,RegSel);
    //****************************Data upper bits-Nibble***************************
    lcdbuffer = ((data & 0xf0)); //upper nibble
    lcdbuffer >>= 4;
    lcdbuffer |= (RegSel | BL | WRITE_LCD);
    lcdbuffer &= ~EN;
    //***************************
    //printf("Buffer is: %x\n",lcdbuffer);
    mcp23008_WriteGPIO(lcdbuffer, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
    //***********
    lcdbuffer |= EN;
    mcp23008_WriteGPIO(lcdbuffer, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
    //***********
    lcdbuffer &= ~EN;
    mcp23008_WriteGPIO(lcdbuffer, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
    //********************************** Lower nibble*******************************
    lcdbuffer = (data & 0x0f);
    lcdbuffer |= RegSel | BL | WRITE_LCD; // Lower nibble
    lcdbuffer &= ~EN;
    //***************************
    //printf("Buffer is: %x\n",lcdbuffer);
    mcp23008_WriteGPIO(lcdbuffer, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
    //***********
    lcdbuffer |= EN;
    mcp23008_WriteGPIO(lcdbuffer, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
    //***********
    lcdbuffer &= ~EN;
    mcp23008_WriteGPIO(lcdbuffer, MCP23008_LCD_ADDR);
    ShortDelay(delay_1ms);
#endif
    
#if LCD_PMP==1
    LCD_LED_HIGH();
    if (RegSel) LCD_DATA_CMD_HIGH();
    else LCD_DATA_CMD_LOW();
    LCD_RW_LOW();
    
    while (mIsPMPBusy()); // Wait for PMP device come out of busy state
    PMDIN = data;
    LCD_ENABLE_LOW();
    ShortDelay(delay_1ms);
    LCD_ENABLE_HIGH();
 #endif
}

void LCD1602_SetCursorPos(UINT8 x, UINT8 y)
{
    UINT8 address;

    switch (y)
    {
    case 1:
        address = LCD2004_LINE_1_ADDRESS;
        break;

    case 2:
        address = LCD2004_LINE_2_ADDRESS;
        break;

    default:
        address = LCD2004_LINE_1_ADDRESS;
        break;
    }
    address += x - 1;
    LCD1602_Write(0x80 | address, 0);
}

void LCD1602_SetCursorBlink(BOOL status)
{
    if (status) LCD1602_Write(LCD_DISPLAYCONTROL | LCD_BLINKON | LCD_CURSORON, 0);
    else LCD1602_Write(LCD_DISPLAYCONTROL | LCD_BLINKOFF | LCD_CURSOROFF, 0);
}

void LCD1602_Putc(UCHAR8 c)
{
    switch (c)
    {
    case '\f':
        LCD1602_Write(LCD_CLEARDISPLAY, 0);
        lcd2004_line = 1;
        ShortDelay(5);
        break;

    case '\n':
        LCD1602_Write(++lcd2004_line, 1);
        break;

    case '\b':
        LCD1602_Write(LCD_CURSOR_DISPLAY_SHIFT | LCD_CURSOR_MOVELEFT, 0);
        break;

    default:
        LCD1602_Write(c, 1);
        break;
    }
}

void LCD1602_SetCursorHome()
{ // works OK
    LCD1602_Write(LCD_RETURNHOME, 0);
}

void LCD1602_SetDisplayClear()
{ // works OK
    LCD1602_Write(LCD_CLEARDISPLAY, 0);
    LCD1602_SetCursorHome();
}

void LCD1602_Printrs(const char * buffer)
{
    while (*buffer)
    {
        LCD1602_Putc(*buffer++);
    }
}

void LCD1602_Prints(char * buffer)
{
    while (*buffer) LCD1602_Putc(*buffer++);
}

void LCD1602_ClearLine(int len, int line)
{
    int i=0;
    for (i=0;i<len;i++)
    {
        LCDI2C_SetCursorPos(1+i,line);
        LCDI2C_Putc(' ');
    }
}

/*
 * Define a special custom character to LCD
 * spclchar = array that define the special character
 * charpos = address space in CGRAM to store the character from 0 to 7
 * Character generator solution online at http://mikeyancey.com/hamcalc/lcd_characters.php
 */
void LCD1602_DefineSpecialChars(const char* spclchar, uint8_t charpos)
{
    int8_t idx = 8;
    LCD1602_Write(LCD_SETCGRAMADDR | (charpos * 8), 0); // Set CGRAM to first Special font space
    while (idx--)
        LCD1602_Write(*spclchar++, 1);
    LCD1602_SetCursorHome();
}

void LCD1602_InitHD44780CustomChars(void)
{
    char i;
    LCD1602_Write(LCD_SETCGRAMADDR, 0);
    for (i = 0; i <= 63; i++)
        LCD1602_Write(SPECCHAR5x8[i], 1);
    LCD1602_SetCursorHome();
}


/*********************************************************************//**
 * @brief		Puts a decimal number to LCD-1602 until 99
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/

void LCD1602PutDec99(uint8_t decnum)
{
    uint8_t c1 = decnum % 10;
    uint8_t c2 = (decnum / 10) % 10;
    //uint8_t c3 = (decnum / 100) % 10;
    //LCD1602_Putc('0' + c3);
    LCD1602_Putc('0' + c2);
    LCD1602_Putc('0' + c1);
}


/*********************************************************************//**
 * @brief		Puts a decimal number to LCD-1602
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/

void LCD1602PutDec(uint8_t decnum)
{
    uint8_t c1 = decnum % 10;
    uint8_t c2 = (decnum / 10) % 10;
    uint8_t c3 = (decnum / 100) % 10;
    LCD1602_Putc('0' + c3);
    LCD1602_Putc('0' + c2);
    LCD1602_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a decimal number to LCD-1602
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/

void LCD1602PutDec16(uint16_t decnum)
{
    uint8_t c1 = decnum % 10;
    uint8_t c2 = (decnum / 10) % 10;
    uint8_t c3 = (decnum / 100) % 10;
    uint8_t c4 = (decnum / 1000) % 10;
    uint8_t c5 = (decnum / 10000) % 10;
    LCD1602_Putc('0' + c5);
    LCD1602_Putc('0' + c4);
    LCD1602_Putc('0' + c3);
    LCD1602_Putc('0' + c2);
    LCD1602_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a decimal number to LCD-1602
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/

void LCD1602PutDec32(uint32_t decnum)
{
    uint8_t c1 = decnum % 10;
    uint8_t c2 = (decnum / 10) % 10;
    uint8_t c3 = (decnum / 100) % 10;
    uint8_t c4 = (decnum / 1000) % 10;
    uint8_t c5 = (decnum / 10000) % 10;
    uint8_t c6 = (decnum / 100000) % 10;
    uint8_t c7 = (decnum / 1000000) % 10;
    uint8_t c8 = (decnum / 10000000) % 10;
    uint8_t c9 = (decnum / 100000000) % 10;
    uint8_t c10 = (decnum / 1000000000) % 10;
    LCD1602_Putc('0' + c10);
    LCD1602_Putc('0' + c9);
    LCD1602_Putc('0' + c8);
    LCD1602_Putc('0' + c7);
    LCD1602_Putc('0' + c6);
    LCD1602_Putc('0' + c5);
    LCD1602_Putc('0' + c4);
    LCD1602_Putc('0' + c3);
    LCD1602_Putc('0' + c2);
    LCD1602_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD-1602 port without the 0x chars
 * @param[in]	hexnum	Hex number (8-bit long)
 * @return		None
 **********************************************************************/

void LCD1602PutHex_(uint8_t hexnum)
{
    uint8_t nibble, i;

    //UARTPuts(UARTx, "0x");
    i = 1;
    do
    {
        nibble = (hexnum >> (4 * i)) & 0x0F;
        LCD1602_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
    }
    while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD-1602
 * @param[in]	hexnum	Hex number (8-bit long)
 * @return		None
 **********************************************************************/

void LCD1602PutHex(uint8_t hexnum)
{
    uint8_t nibble, i;

    LCD1602_Prints("0x");
    i = 1;
    do
    {
        nibble = (hexnum >> (4 * i)) & 0x0F;
        LCD1602_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
    }
    while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD-1602
 * @param[in]	hexnum	Hex number (16-bit long)
 * @return		None
 **********************************************************************/

void LCD1602PutHex16(uint16_t hexnum)
{
    uint8_t nibble, i;

    LCD1602_Prints("0x");
    i = 3;
    do
    {
        nibble = (hexnum >> (4 * i)) & 0x0F;
        LCD1602_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
    }
    while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD-1602
 * @param[in]	hexnum	Hex number (32-bit long)
 * @return		None
 **********************************************************************/

void LCD1602PutHex32(uint32_t hexnum)
{
    uint8_t nibble, i;

    LCD1602_Prints("0x");
    i = 7;
    do
    {
        nibble = (hexnum >> (4 * i)) & 0x0F;
        LCD1602_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
    }
    while (i--);
}
