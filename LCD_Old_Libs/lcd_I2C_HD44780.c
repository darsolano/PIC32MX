

#include "LCDDRV_HD44780.h"
#include "utilities.h"
#include "mypic32_i2c.h"

//Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
//MikroeElektronika 2011
//http://www.mikroe.com

//HD44780 Alpha Numeric Character Set - FontName : RTC5x8
//HD44780 Alpha Numeric Character Set - FontSize : 5 x 8

const uint8_t RTC5x8[] = {
    0x08, 0x14, 0x08, 0x03, 0x04, 0x07, 0x04, 0x04, // Code for char num #0 Faranheit
    0x08, 0x14, 0x08, 0x03, 0x04, 0x04, 0x03, 0x00, // Code for char num #1 Celcius
    0x04, 0x0A, 0x0E, 0x0A, 0x00, 0x1A, 0x15, 0x15, // Code for char num #2 AM
    0x04, 0x0A, 0x0C, 0x08, 0x00, 0x1A, 0x15, 0x15, // Code for char num #3 PM
    0x0C, 0x12, 0x12, 0x0C, 0x00, 0x00, 0x00, 0x00, // Code for char num #4 Degrees
    0x00, 0x01, 0x01, 0x05, 0x05, 0x15, 0x15, 0x00, // Code for char num #5 Bar
    0x00, 0x15, 0x0E, 0x04, 0x04, 0x04, 0x04, 0x00, // Code for char num #6 Antenna
    0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x00 // Code for char num #7 Battery Full
};

const uint8_t SPECIAL_1_5x8[] = {
    0x02, 0x05, 0x01, 0x12, 0x07, 0x13, 0x14, 0x13, // Code for char num #0 - i2c
    0x04, 0x0E, 0x0E, 0x0E, 0x0E, 0x1F, 0x00, 0x04, // Code for char num #1 - Bell
    0x1C, 0x14, 0x1C, 0x0E, 0x0B, 0x0E, 0x03, 0x02, // Code for char num #2 - Off
    0x1C, 0x14, 0x1C, 0x00, 0x12, 0x1A, 0x16, 0x00, // Code for char num #3 - On
    0x01, 0x03, 0x05, 0x09, 0x09, 0x0B, 0x1B, 0x18, // Code for char num #4 - Music
    0x00, 0x0A, 0x1F, 0x1F, 0x1F, 0x0E, 0x04, 0x00, // Code for char num #5 - Heart
    0x04, 0x0E, 0x1F, 0x04, 0x04, 0x04, 0x04, 0x00, // Code for char num #6 - Up
    0x04, 0x04, 0x04, 0x04, 0x1F, 0x0E, 0x04, 0x00 // Code for char num #7 - Down
};

const char CELSIUS[]={
    0x08, 0x14, 0x08, 0x03, 0x04, 0x04, 0x03, 0x00 // Code for char num  - CELSIUS
};

const char UP[]={
    0x04, 0x0E, 0x1F, 0x04, 0x04, 0x04, 0x04, 0x00 // Code for char num  - Up
};

const char DOWN[]={
    0x04, 0x04, 0x04, 0x04, 0x1F, 0x0E, 0x04, 0x00 // Code for char num  - Down
};

const char ENTER_KEY[] = {
	0b00001,
	0b00001,
	0b00101,
	0b01101,
	0b11111,
	0b01100,
	0b00100,
	0b00000
};

UINT8 buff[12];
UINT8 lcdbuffer; // Buffer to hold data to tranfer to LCD
UINT32 actualClock;
UINT8 lcd2004_line;
I2C_RESULT status;


PRIVATE I2C_RESULT lcd_WriteData ( UCHAR8* buffer, UCHAR8 len, UCHAR8 addr )
{
    /* Sets data to be send to MCP23008 to init*/
    I2C_MData_Cfg_sType i2ctx; //Data structure to be used to send byte thru I2C Master Data Transfer

    // Fill Data Structure with proper data
    i2ctx.prxBuff = 0;
    i2ctx.rxDataLen = 0;
    i2ctx.sl_addr_7bit = addr;
    i2ctx.ptxBuff = buffer;
    i2ctx.txDataLen = len;
    // Send data to I2C
    ShortDelay (delay_1ms);
    status = I2C_MasterDataTransfer ( LCD_I2C_BUS, &i2ctx );
    return status;
}

void LCDI2C_Init ( void )
{
    I2CInitDevice(LCD_I2C_BUS , B400KHz);
    
    //first init string
    ShortDelay (delay_10ms);
    buff[0] = (0x3C);
    lcd_WriteData ( buff, 1, LCD_I2C_ADDR );
    ShortDelay ( delay_5ms );
    buff[0] = (0x38);
    lcd_WriteData ( buff, 1, LCD_I2C_ADDR );
    ShortDelay ( delay_5ms );

    //second init string
    buff[0] = (0x3C);
    lcd_WriteData ( buff, 1, LCD_I2C_ADDR );
    ShortDelay ( delay_5ms );
    buff[0] = (0x38);
    lcd_WriteData ( buff, 1, LCD_I2C_ADDR );
    ShortDelay ( delay_5ms );

    //third init string
    buff[0] = (0x3C);
    lcd_WriteData ( buff, 1, LCD_I2C_ADDR );
    ShortDelay ( delay_5ms );
    buff[0] = (0x38);
    lcd_WriteData ( buff, 1, LCD_I2C_ADDR );
    ShortDelay ( delay_5ms );

    //fourth init string
    // 4 bits mode, only per indications of initializaton
    buff[0] = (0x2C);
    lcd_WriteData ( buff, 1, LCD_I2C_ADDR );
    ShortDelay ( delay_5ms );
    buff[0] = (0x28);
    lcd_WriteData ( buff, 1, LCD_I2C_ADDR );
    ShortDelay ( delay_5ms );


    // 4 bits mode, only per indications of initializaton
    LCDI2C_Write ( LCD_FUNCTIONSET | LCD_5x8DOTS | LCD_4BITMODE | LCD_2LINE, 0 );

    // Display ON
    LCDI2C_Write ( LCD_DISPLAYCONTROL | LCD_DISPLAYON, 0 );

    // Clear Display,
    LCDI2C_Write ( LCD_CLEARDISPLAY, 0 );

    // Entry Mode Set
    LCDI2C_Write ( LCD_ENTRYMODESET | LCD_ENTRYLEFT, 0 );
    
    LCDI2C_InitHD44780CustomChars();
}

void LCDI2C_SetDisplayOnOff ( BOOL status )
{
    if (status) {
        LCDI2C_Write ( LCD_DISPLAYCONTROL | LCD_DISPLAYON, 0 );
    } else {
        LCDI2C_Write ( LCD_DISPLAYCONTROL | LCD_DISPLAYOFF, 0 );
    }
}

void LCDI2C_ClearLine(int len, int line)
{
    int i=0;
    for (i=0;i<len;i++)
    {
        LCDI2C_SetCursorPos(1+i,line);
        LCDI2C_Putc(' ');
    }
}

void LCDI2C_SetCursorOnOff ( BOOL status )
{
    if (status) {
        LCDI2C_Write ( LCD_DISPLAYCONTROL | LCD_CURSORON, 0 );
    } else {
        LCDI2C_Write ( LCD_DISPLAYCONTROL | LCD_CURSOROFF, 0 );
    }
}

void LCDI2C_Write ( UCHAR8 data, UCHAR8 RS )
{
    //****************************Data upper bits-Nibble***************************
    lcdbuffer = ((data & 0xf0) | RS | LCD_BACKLIGHT); //upper nibble
    lcdbuffer &= ~En;
    //***************************
    buff[0] = lcdbuffer;
    lcd_WriteData (buff,1,LCD_I2C_ADDR);
    //***********
    lcdbuffer |= En;
    buff[0] = lcdbuffer;
    lcd_WriteData (buff,1,LCD_I2C_ADDR);
    //***********
    lcdbuffer &= ~En;
    buff[0] = lcdbuffer;
    lcd_WriteData (buff,1,LCD_I2C_ADDR);
    //********************************** Lower nibble*******************************
    lcdbuffer = (data & 0x0f);
    lcdbuffer <<= 4;
    lcdbuffer |= RS | LCD_BACKLIGHT; // Lower nibble
    lcdbuffer &= ~En;
    //***************************
    buff[0] = lcdbuffer;
    lcd_WriteData (buff,1,LCD_I2C_ADDR);
    //***********
    lcdbuffer |= En;
    buff[0] = lcdbuffer;
    lcd_WriteData (buff,1,LCD_I2C_ADDR);
    //***********
    lcdbuffer &= ~En;
    buff[0] = lcdbuffer;
    lcd_WriteData (buff,1,LCD_I2C_ADDR);
}

void LCDI2C_SetCursorPos ( UINT8 x, UINT8 y )
{
    UINT8 address;

    switch (y) {
        case 1:
            address = LCD2004_LINE_1_ADDRESS;
            break;

        case 2:
            address = LCD2004_LINE_2_ADDRESS;
            break;

        case 3:
            address = LCD2004_LINE_3_ADDRESS;
            break;

        case 4:
            address = LCD2004_LINE_4_ADDRESS;
            break;

        default:
            address = LCD2004_LINE_1_ADDRESS;
            break;
    }
    address += x - 1;
    LCDI2C_Write ( 0x80 | address, 0 );
}

void LCDI2C_SetCursorBlink ( BOOL status )
{
    if (status) LCDI2C_Write ( LCD_DISPLAYCONTROL | LCD_BLINKON, 0 );
    else LCDI2C_Write ( LCD_DISPLAYCONTROL | LCD_BLINKOFF, 0 );
}

void LCDI2C_Putc ( UCHAR8 c )
{
    switch (c) {
        case '\f':
            LCDI2C_Write ( LCD_CLEARDISPLAY, 0 );
            lcd2004_line = 1;
            ShortDelay ( 5 );
            break;

        case '\n':
            LCDI2C_Write ( ++lcd2004_line, Rs );
            break;

        case '\b':
            LCDI2C_Write ( LCD_CURSOR_DISPLAY_SHIFT | LCD_CURSOR_MOVELEFT, 0 );
            break;

        default:
            LCDI2C_Write ( c, Rs );
            break;
    }
}

void LCDI2C_SetCursorHome ( )
{ // works OK
    LCDI2C_Write ( LCD_RETURNHOME, 0 );
}

void LCDI2C_SetDisplayClear ( )
{ // works OK
    LCDI2C_Write ( LCD_CLEARDISPLAY, 0 );
    LCDI2C_SetCursorHome ( );
}

void LCDI2C_Printrs ( const char * buffer )
{
    while (*buffer) {
        LCDI2C_Putc ( *buffer++ );
    }
}

void LCDI2C_Prints ( char * buffer )
{
    while (*buffer) LCDI2C_Putc ( *buffer++ );
}

/*
 * Define a special custom character to LCD
 * spclchar = array that define the special character
 * charpos = address space in CGRAM to store the character from 0 to 7
 * Character generator solution online at http://mikeyancey.com/hamcalc/lcd_characters.php
 */
void LCDI2C_DefineSpecialChars(const char* spclchar, uint8_t charpos)
{
    int8_t idx = 8;
    LCDI2C_Write(LCD_SETCGRAMADDR | (charpos * 8), 0); // Set CGRAM to first Special font space
    while (idx--)
        LCDI2C_Write(*spclchar++, Rs);
    LCDI2C_SetCursorHome();
}

void LCDI2C_InitHD44780CustomChars(void)
{
    char i;
    LCDI2C_Write(LCD_SETCGRAMADDR, 0);
    for (i = 0; i <= 63; i++)
        LCDI2C_Write(RTC5x8[i], Rs);
    LCDI2C_SetCursorHome();
}


/*********************************************************************//**
 * @brief		Puts a decimal number to LCD until 99
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/

void LCDI2C_PutDec99(uint8_t decnum)
{
    uint8_t c1 = decnum % 10;
    uint8_t c2 = (decnum / 10) % 10;
    //uint8_t c3 = (decnum / 100) % 10;
    //LCDI2C_Putc('0' + c3);
    LCDI2C_Putc('0' + c2);
    LCDI2C_Putc('0' + c1);
}


/*********************************************************************//**
 * @brief		Puts a decimal number to LCD
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/

void LCDI2C_PutDec(uint8_t decnum)
{
    uint8_t c1 = decnum % 10;
    uint8_t c2 = (decnum / 10) % 10;
    uint8_t c3 = (decnum / 100) % 10;
    LCDI2C_Putc('0' + c3);
    LCDI2C_Putc('0' + c2);
    LCDI2C_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a decimal number to LCD
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/

void LCDI2C_PutDec16(uint16_t decnum)
{
    uint8_t c1 = decnum % 10;
    uint8_t c2 = (decnum / 10) % 10;
    uint8_t c3 = (decnum / 100) % 10;
    uint8_t c4 = (decnum / 1000) % 10;
    uint8_t c5 = (decnum / 10000) % 10;
    LCDI2C_Putc('0' + c5);
    LCDI2C_Putc('0' + c4);
    LCDI2C_Putc('0' + c3);
    LCDI2C_Putc('0' + c2);
    LCDI2C_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a decimal number to LCD
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/

void LCDI2C_PutDec32(uint32_t decnum)
{
    uint8_t c1 = decnum % 10;
    uint8_t c2 = (decnum / 10) % 10;
    uint8_t c3 = (decnum / 100) % 10;
    uint8_t c4 = (decnum / 1000) % 10;
    uint8_t c5 = (decnum / 10000) % 10;
    uint8_t c6 = (decnum / 100000) % 10;
    uint8_t c7 = (decnum / 1000000) % 10;
    uint8_t c8 = (decnum / 10000000) % 10;
    uint8_t c9 = (decnum / 100000000) % 10;
    uint8_t c10 = (decnum / 1000000000) % 10;
    LCDI2C_Putc('0' + c10);
    LCDI2C_Putc('0' + c9);
    LCDI2C_Putc('0' + c8);
    LCDI2C_Putc('0' + c7);
    LCDI2C_Putc('0' + c6);
    LCDI2C_Putc('0' + c5);
    LCDI2C_Putc('0' + c4);
    LCDI2C_Putc('0' + c3);
    LCDI2C_Putc('0' + c2);
    LCDI2C_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD port without the 0x chars
 * @param[in]	hexnum	Hex number (8-bit long)
 * @return		None
 **********************************************************************/

void LCDI2C_PutHex_(uint8_t hexnum)
{
    uint8_t nibble, i;

    //UARTPuts(UARTx, "0x");
    i = 1;
    do
    {
        nibble = (hexnum >> (4 * i)) & 0x0F;
        LCDI2C_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
    }
    while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD
 * @param[in]	hexnum	Hex number (8-bit long)
 * @return		None
 **********************************************************************/

void LCDI2C_PutHex(uint8_t hexnum)
{
    uint8_t nibble, i;

    LCDI2C_Prints("0x");
    i = 1;
    do
    {
        nibble = (hexnum >> (4 * i)) & 0x0F;
        LCDI2C_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
    }
    while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD
 * @param[in]	hexnum	Hex number (16-bit long)
 * @return		None
 **********************************************************************/

void LCDI2C_PutHex16(uint16_t hexnum)
{
    uint8_t nibble, i;

    LCDI2C_Prints("0x");
    i = 3;
    do
    {
        nibble = (hexnum >> (4 * i)) & 0x0F;
        LCDI2C_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
    }
    while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD
 * @param[in]	hexnum	Hex number (32-bit long)
 * @return		None
 **********************************************************************/

void LCDI2C_PutHex32(uint32_t hexnum)
{
    uint8_t nibble, i;

    LCDI2C_Prints("0x");
    i = 7;
    do
    {
        nibble = (hexnum >> (4 * i)) & 0x0F;
        LCDI2C_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
    }
    while (i--);
}
